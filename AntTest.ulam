/**
   \symbol AT
   \color #00f
 */
element AntTest : QBondableT(1u) + QMortal {
  typedef TreeData.Datum Datum;
  typedef TreeData.Symbol Symbol;
  typedef TreeData.Type Type;
  typedef TreeData.Arity Arity;

  constant QBond.Index cSEQUENCE = 0u;

  Unsigned mCount = 0u;

  @Override Void behave() {
    EventWindow ew;

    if (mCount < AntSequenceData.cSIZE) {
      // Build next sequence item
      AntSequenceData data;
      SequenceBuilder builder;
      Datum datum = prepareSeqData(data.data[mCount]);
      if (builder.buildNext(ew[0], datum, cSEQUENCE))
        mCount++;

    } else {
      // Attach the builder

      BondUtils bu;
      EventWindowMisc ewm;

      SiteNum site = ewm.findEmptySite(QBond.cMAX_DIST);
      if (site == SiteNum.maxof)
        return;

      AntTreeBuilder builder;
      ew[site] = builder;

      QBond& seqBond = getBond(cSEQUENCE); // assuming always attached
      SiteNum seqSite = seqBond.getSiteNumber();

      // Replace oursleves with the builder
      BondUtils.Status status = bu.replace(seqSite, Sequence.cCOMMON, site, AntTreeBuilder.cSEQUENCE, Sequence.cCOMMON);
      if (!bu.isOk(status)) {
        // cleanup
        Empty empty;
        ew[site] = empty;
        return;
      }

      die(); // done
    }
  }

  Datum prepareSeqData(Symbol symbol) {
    TreeData td;
    Datum datum = 0x0;

    Type type = TreeData.cTYPE_FUNCTION;
    if (symbol == Ant.cCONDITIONAL_IF_FOOD_AHEAD)
      type = TreeData.cTYPE_CONDITIONAL;

    Arity arity = 0u;
    if (symbol == Ant.cCONDITIONAL_IF_FOOD_AHEAD ||
        symbol == Ant.cFUNCTION_PROGN)
    {
      arity = 2u;
    }

    datum = td.setArity(datum, arity);
    datum = td.setType(datum, type);
    datum = td.setSymbol(datum, symbol);

    return datum;
  }
}


/**
   \symbol AB
   \color #fff
 */
element AntTreeBuilder : QTreeBuilder + QBondableT(3u) + QDiffusableT(1000u) + QMortal {
  typedef EventWindow.SiteNum SiteNum;

  constant State cSTATE_PLACING_MOVER = cSTATE_DONE_BUILDING; // alias
  constant State cSTATE_PLACING_TRAIL = cSTATE_FIRST_UNRESERVED;
  constant State cSTATE_PLACING_ANT = cSTATE_PLACING_TRAIL + 1u;
  constant State cSTATE_DONE = cSTATE_PLACING_ANT + 1u;

  @Override IBondable& getBondable() {
    return self;
  }

  @Override Void behave() {
    step();

    if (mState == cSTATE_DONE || mState == cSTATE_ERROR) {
      getBond(cSEQUENCE).breakup();
      getBond(cTREE).breakup();
      die();

    } else if (getState() < cSTATE_PLACING_TRAIL) { // stand still when placing stuff
      diffuse();
    }
  }

  Void step() {
    self.QTreeBuilder.step();
    if (getState() == cSTATE_PLACING_MOVER) {
      placeMover();
    } else if (getState() == cSTATE_PLACING_TRAIL) {
      placeTrail();
    } else if (getState() == cSTATE_PLACING_ANT) {
      placeAnt();
    }
  }

  /**
     Attach a mover to the sequence to drag it away
   */
  Void placeMover() {
    BondUtils bu;
    EventWindow ew;
    EventWindowMisc ewm;

    QBond& seqBond = getBond(cSEQUENCE); // assume attached
    SiteNum site = ewm.findEmptySiteAround(seqBond.getCoord(), 1u, QBond.cMAX_DIST);
    if (site == SiteNum.maxof)
      return;

    Mover mover;
    ew[site] = mover;

    // Replace ourselves with mover
    SiteNum seqSite = seqBond.getSiteNumber();
    BondUtils.Status status = bu.replace(seqSite, Sequence.cCOMMON, site, Mover.cCOMMON, Sequence.cCOMMON);
    if (!bu.isOk(status)) {
      // cleanup
      Empty empty;
      ew[site] = empty;
      return;
    }

    setState(cSTATE_PLACING_TRAIL);
  }

  Void placeTrail() {
    EventWindow ew;

    C2D startCoord(2, 0);
    if (!ew.isEmpty(startCoord))
      return;

    // Start building the trail
    AntTestTrailBuilder builder;
    ew[startCoord] = builder;

    setState(cSTATE_PLACING_ANT);
  }

  Void placeAnt() {
    BondUtils bu;
    EventWindow ew;

    C2D coord(1, 0);
    SiteNum site = ew.getSiteNumber(coord);
    if (!ew.isEmpty(site))
      return;

    Ant ant;
    ew[site] = ant;

    // Replace ourselves with the ant
    QBond& treeBond = getBond(cTREE); // assuming always attached
    SiteNum treeSite = treeBond.getSiteNumber();
    BondUtils.Status status = bu.replace(treeSite, Tree.cCOMMON, site, Ant.cTREE, Tree.cCOMMON);
    if (!bu.isOk(status)) {
      // cleanup
      Empty empty;
      ew[site] = empty;
      return;
    }

    setState(cSTATE_DONE);
  }
}


/**
   \symbol AP
   \color #f30
 */
element AntTestTrailBuilder : QMortal {
  typedef AntTrailData.Move Move;
  typedef C2D.Dir Dir;

  constant Unsigned cPART_NUM = 6u;

  Unsigned mPart = 0u;
  Unsigned mIndex = 0u;

  Dir mDir = 2u; // east
  Bool mIsMoving = false;
  Bool mIsPlacing = false;
  Bool mPlaceAfterMove = false;
  Bool mIsFirstMove = true;

  @Override Void behave() {
    if (mIsMoving) {
      swapForwardAndPlace();
      return;
    }

    if (mPart >= cPART_NUM) {
      die();
      return;
    }

    Move move;
    if (mPart == 0u) {
      AntTrailData0 part;
      move = part.data[mIndex++];
      if (mIndex >= AntTrailData0.cSIZE) {
        mPart++;
        mIndex = 0u;
      }
    } else if (mPart == 1u) {
      AntTrailData1 part;
      move = part.data[mIndex++];
      if (mIndex >= AntTrailData1.cSIZE) {
        mPart++;
        mIndex = 0u;
      }
    } else if (mPart == 2u) {
      AntTrailData2 part;
      move = part.data[mIndex++];
      if (mIndex >= AntTrailData2.cSIZE) {
        mPart++;
        mIndex = 0u;
      }
    } else if (mPart == 3u) {
      AntTrailData3 part;
      move = part.data[mIndex++];
      if (mIndex >= AntTrailData3.cSIZE) {
        mPart++;
        mIndex = 0u;
      }
    } else if (mPart == 4u) {
      AntTrailData4 part;
      move = part.data[mIndex++];
      if (mIndex >= AntTrailData4.cSIZE) {
        mPart++;
        mIndex = 0u;
      }
    } else if (mPart == 5u) {
      AntTrailData5 part;
      move = part.data[mIndex++];
      if (mIndex >= AntTrailData5.cSIZE) {
        mPart++;
        mIndex = 0u;
      }
    }
    exec(move);
  }

  Void exec(Move move) {
    if (move == AntTrailData.cFORWARD) {
      forward();
    } else if (move == AntTrailData.cLEFT) {
      left();
    } else if (move == AntTrailData.cRIGHT) {
      right();
    } else { // AntTrailData.cPLACE
      place();
    }
  }

  Void forward() {
    mIsMoving = true;
  }

  Void left() {
    mDir = (Dir) (((Int) mDir + 2) % 8);
  }

  Void right() {
    mDir = (Dir) (((Int) mDir + 6) % 8);
  }

  Void place() {
    mPlaceAfterMove = true;
    forward();
  }

  Void swapForwardAndPlace() {
    EventWindow ew;

    C2D coord = getForwardCoord();
    if (!ew.isEmpty(coord))
      return;

    if (mIsFirstMove) {
      AntTrailStart start;
      ew[coord] = start;
      mIsFirstMove = false;

    } else if (mIsPlacing) {
      AntFood food;
      ew[coord] = food;
    }

    mIsMoving = false;
    mIsPlacing = mPlaceAfterMove;
    mPlaceAfterMove = false;
    ew.swap(0, ew.getSiteNumberRaw(coord));


  }

  C2D getForwardCoord() {
    C2D origin;
    return origin.neighbor(mDir);
  }

  @Override Void renderGraphics() {
    Drawable drawable;
    if (!drawable.canDraw())
      return;

    C2D start;
    C2D end = start.neighbor(mDir) * (Drawable.cUNITS_PER_SITE * 3 / 4);

    ColorUtils cu;
    ARGB oncol = cu.color(0x00ff3300);
    ARGB offcol = oncol;

    drawable.drawMaskedLine(start, end, oncol, offcol, 0xffffffff);
  }
}


transient AntSequenceData {
  // constant Unsigned cSIZE = 5u;
  constant Unsigned cSIZE = 17u;

  typedef Unsigned(3) Symbol;

  constant Symbol cIF_FOOD_AHEAD = 0x1;
  constant Symbol cFORWARD       = 0x2;
  constant Symbol cLEFT          = 0x3;
  constant Symbol cRIGHT         = 0x4;
  constant Symbol cPROGN         = 0x5;

  // Symbol data[cSIZE] = {
  //   cIF_FOOD_AHEAD,
  //   cFORWARD,
  //   cPROGN, cLEFT, cFORWARD};

  // Actual solution
  Symbol data[cSIZE] = {
    /* */ cIF_FOOD_AHEAD,
    /*   */ cPROGN,
    /*     */ cFORWARD,
    /*     */ cPROGN,
    /*       */ cFORWARD,
    /*       */ cRIGHT,
    /*   */ cPROGN,
    /*     */ cPROGN,
    /*       */ cPROGN,
    /*         */ cLEFT,
    /*         */ cPROGN,
    /*           */ cFORWARD,
    /*           */ cLEFT,
    /*     */ cIF_FOOD_AHEAD,
    /*       */ cFORWARD,
    /*       */ cRIGHT,
    /*   */ cRIGHT
  };
}


transient AntTrailData {
  typedef Unsigned(2) Move;
  typedef Unsigned(6) Size;

  constant Move cFORWARD = 0u;
  constant Move cLEFT = 1u;
  constant Move cRIGHT = 2u;
  constant Move cPLACE = 3u; // move forward and place
}


// Santa Fe ant trail packaged into multiple transients:

transient AntTrailData0 : AntTrailData {
  constant Size cSIZE = 32u;
  /*
      (1)
     >###
        #
        # (2)
        #
        #   (3)
        ####.#####
                 #
                 #
                 #
                 #
                 #
                 .
                 #
                 # (4.1)
                 #
                 #
                 .
                 .
                 v
   */
  Move data[cSIZE] = {
    3, 3, 3, 2,                        // (1)
    3, 3, 3, 3, 3, 1,                  // (2)
    3, 3, 3, 0, 3, 3, 3, 3, 3, 2,      // (3)
    3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 0, 0 // (4.1)
  };
}

transient AntTrailData1 : AntTrailData {
  constant Size cSIZE = 27u;
  /*
                  v
                  #
                  #
                  # (4.2)
                  #
                  #
           (5)    #
       ..##..#####.
       #
       #
   (6) #
       #
       .
       .>
   */
  Move data[cSIZE] = {
    3, 3, 3, 3, 3, 3, 0, 2,             // (4.2)
    3, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 1, // (5)
    3, 3, 3, 3, 0, 0, 1                 // (6)
  };
}

transient AntTrailData2 : AntTrailData {
  constant Size cSIZE = 27u;
  /*
                      ^
                      #
                      .
                      . (10.1)
                      #
                      #
                      #
             .#######..
         (8) #   (9)
             #
      >####..
         (7)
   */
  Move data[cSIZE] = {
    3, 3, 3, 3, 0, 0, 1,          // (7)
    3, 3, 0, 2,                   // (8)
    3, 3, 3, 3, 3, 3, 3, 0, 0, 1, // (9)
    3, 3, 3, 0, 0, 3              // (10.1)
  };
}

transient AntTrailData3 : AntTrailData {
  constant Size cSIZE = 32u;
  /*
                                 .>
                                 # (14)
                            (13) #
                             .##..
                             .
                             .
                             #
                             #
                             # (12)
                             #
                             .
                             .
                             #
                             #
                         .#...
                         # (11)
                         #
                  (10.2) #
                         .
                         ^
   */
  Move data[cSIZE] = {
    0, 3, 3, 3, 0, 2,                   // (10.2)
    3, 0, 0, 0, 1,                      // (11)
    3, 3, 0, 0, 3, 3, 3, 3, 0, 0, 0, 2, // (12)
    3, 3, 0, 0, 1,                      // (13)
    3, 3, 0, 2                          // (14)
  };
}

transient AntTrailData4 : AntTrailData {
  constant Size cSIZE = 26u;
  /*
                                   (15)
                                  >###..
                                       #
                                       #
                                       .
                                       #
                                       .
                                       . (16)
                                       #
                                       .
                                       .
                                       #
                                  (17) .
                                 ...###.
                                 v
   */
  Move data[cSIZE] = {
    3, 3, 3, 0, 0, 2,                      // (15)
    3, 3, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0, 2, // (16)
    3, 3, 3, 0, 0, 0, 1                    // (17)
  };
}

transient AntTrailData5 : AntTrailData {
  constant Size cSIZE = 22u;
  /*
                                 v
                                 #
                                 .
                            (18) .  (19)
                                 .#...
                                     #
                                     . (20)
                               (21)  .
                                 ...#.
                                 #
                                 x
   */
  Move data[cSIZE] = {
    3, 0, 0, 0, 1, // (18)
    3, 0, 0, 0, 2, // (19)
    3, 0, 0, 0, 2, // (20)
    3, 0, 0, 0, 1, // (21)
    3, 0
  };
}
