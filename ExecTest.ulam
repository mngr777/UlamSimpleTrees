/**
   Dummy element matching file name to keep compiler happy 

   \placeable no
 */
element ExecTest {}

/**
   \symbol E1
   \color #00f
 */
element ExecDemo1_RewindSequence : QExecTest(1u) + QBondableT(1u) {
  @Override Void behave() {
    if (buildNext(self) && attachTreeBuilder(self))
      die();
  }
}

/**
   \symbol E2
   \color #00f
 */
element ExecDemo2_CopySequenceToMemory : QExecTest(2u) + QBondableT(1u) {
  @Override Void behave() {
    if (buildNext(self) && attachTreeBuilder(self))
      die();
  }
}

/**
   \symbol E3
   \color #00f
 */
element ExecDemo3_TreeFromSequence : QExecTest(3u) + QBondableT(1u) {
  @Override Void behave() {
    if (buildNext(self) && attachTreeBuilder(self))
      die();
  }
}

/**
   Shared demo code, stage 1:
   - build selected sequence;
   - attach `ExecTestTreeBuilder` to set up stage 2
 */
quark QExecTest(Unsigned cDEMO = 1u) + QMortal + Fail {
  typedef EventWindow.SiteNum SiteNum;

  typedef DataUtils.Byte Byte;
  typedef TreeData.Datum Datum;
  typedef TreeData.Symbol Symbol;
  typedef TreeData.Type Type;
  typedef TreeData.Arity Arity;

  typedef ExecTestSequenceData.Size Size;
  typedef ExecTestSequenceData.Item Item;

  constant QBond.Index cOUTPUT= 0u;

  Size mCount = 0u;

  Bool buildNext(Atom& demo) {
    if (mCount >= getDataSize())
      return true;

    SequenceBuilder builder;
    Datum data = getData(mCount);
    if (builder.buildNext(demo, data, cOUTPUT))
      mCount++;
    return false;
  }

  Bool attachTreeBuilder(Atom& demo) {
    BondUtils bu;
    EventWindow ew;
    EventWindowMisc ewm;

    SiteNum site = ewm.findEmptySite(1u, QBond.cMAX_DIST);
    if (site == SiteNum.maxof)
      return false;

    ExecTestTreeBuilder builder;
    ew[site] = builder;

    IBondable& bondable = (IBondable&) demo;
    QBond& seqBond = bondable.getBond(cOUTPUT);
    SiteNum seqSite = seqBond.getSiteNumber();

    // Replace demo with the builder
    BondUtils.Status status = bu.replace(seqSite, seqBond.getIndex(), site, ExecTestTreeBuilder.cSEQUENCE, Sequence.cCOMMON);
    if (bu.isError(status)) {
      Fail fl;
      fl.fail("Failed to replace with builder");
      return false;

    } else if (!bu.isOk(status)) {
      // cleanup
      Empty empty;
      ew[site] = empty;
      return false;
    }
    return true;
  }

  Size getDataSize() {
    if (cDEMO == 1u) {
      return ExecTestRewindData.cSIZE;

    } else if (cDEMO == 2u) {
      return ExecTestCopyData.cSIZE;

    } else if (cDEMO == 3u) {
      return ExecTreeBuildData.cSIZE;

    } else {
      Fail fl;
      fl.fail("Invalid demo number");
      return 0u;
    }
  }

  Datum getData(Size num) {
    Item item = 0x0;

    if (cDEMO == 1u) {
      ExecTestRewindData data;
      item = data.data[num];

    } else if (cDEMO == 2u) {
      ExecTestCopyData data;
      item = data.data[num];

    } else if (cDEMO == 3u) {
      ExecTreeBuildData data;
      item = data.data[num];

    } else {
      Fail fl;
      fl.fail("Invalid demo number");
    }

    return prepareSequenceData(item);
  }

  Datum prepareSequenceData(Item item) {
    ExecTestSequenceData sd;
    TreeData td;
    TreeExec exec;

    Type type = sd.getType(item);
    Byte value = sd.getValue(item);
    Arity arity = exec.getArity(type, (Symbol) value);

    Datum datum = TreeData.cNODATA;
    datum = td.setArity(datum, arity);
    datum = td.setType(datum, type);
    datum = td.setValue(datum, value);
    return datum;
  }
}


/**
   Setting up stage 2:
   - build a tree from the sequence;
   - attach the tree to a "general purpose" executor `TreeExec`;
   - attach the sequence to the executor as input (reusing the original sequence for simplicity)

   \symbol EB
 */
element ExecTestTreeBuilder : QTreeBuilder + QBondableT(3u) + QDiffusableT(1000u) + QMortal + Fail {
  constant QBond.Index cEXEC = 2u;

  constant State cSTATE_PLACING_EXEC = cSTATE_DONE_BUILDING; // alias
  constant State cSTATE_ATTACHING_PROGRAM = cSTATE_FIRST_UNUSED;
  constant State cSTATE_DONE = cSTATE_ATTACHING_PROGRAM + 1u;

  @Override IBondable& getBondable() {
    return self;
  }

  @Override Void behave() {
    step();

    if (getState() == cSTATE_DONE || getState() == cSTATE_ERROR) {
      die();

    } else {
      diffuse();
    }
  }

  Void step() {
    self.QTreeBuilder.step();

    if (getState() == cSTATE_PLACING_EXEC) {
      placeExecAndAttachSequence();

    } else if (getState() == cSTATE_ATTACHING_PROGRAM) {
      attachProgram();
    }
  }

  Void placeExecAndAttachSequence() {
    BondUtils bu;
    DebugUtils du;
    EventWindow ew;
    EventWindowMisc ewm;

    du.print("placing executor");

    QBond& seqBond = getBond(cSEQUENCE);
    SiteNum site = ewm.findEmptySiteAround(seqBond.getSiteNumber(), 1u, QBond.cMAX_DIST);
    if (site == SiteNum.maxof)
      return;

    TreeExec exec;
    ew[site] = exec;

    // Hold it in place by memory bond
    // (it could also be output: we need to attach the sequence to input, and
    // executor tries to run anything attached as program)
    QBond& execBond = getBond(cEXEC);
    if (!execBond.bond(0u, cEXEC, site, TreeExec.cMEMORY)) {
      // cleanup
      Empty empty;
      ew[site] = empty;
      return;
    }


    // transfer input sequence to exec.
    du.print("transferring input sequence to executor");
    BondUtils.Status status = bu.transfer(0u, cSEQUENCE, site, TreeExec.cINPUT, Sequence.cCOMMON);
    if (bu.isError(status)) {
      fail("ExecTestTreeBuilder.placeExecAndAttachSequence: failed to transfer input sequence to executor");
      return;

    } else if (!bu.isOk(status)) {
      du.print("retrying sequence transfer");
      // cleanup
      Empty empty;
      ew[site] = empty;
      return;
    }

    setState(cSTATE_ATTACHING_PROGRAM);
  }

  Void attachProgram() {
    BondUtils bu;
    EventWindow ew;

    QBond& execBond = getBond(cEXEC);
    SiteNum execSite = execBond.getSiteNumber();

    // Transfer the tree to the executor
    BondUtils.Status status = bu.transfer(0u, cTREE, execSite, TreeExec.cPROGRAM, Tree.cCOMMON);
    if (bu.isError(status)) {
      fail("ExecTestTreeBuilder.attachProgram: failed to transfer program tree to executor");
      return;

    } else if (bu.isOk(status)) {
      // TEST
      DebugUtils du;
      du.print("program transferred");

      setState(cSTATE_DONE);
    } else {
      // TEST
      DebugUtils du;
      du.print("retrying program transfer");
    }
  }
}


transient ExecTestSequenceData {
  typedef DataUtils.Byte Byte;
  typedef TreeData.Type Type;
  typedef Bits(Type.sizeof + Byte.sizeof) Item;

  typedef Unsigned(6) Size;

  constant Item cFUNC = TreeData.cTYPE_FUNCTION << Byte.sizeof;
  constant Item cCOND = TreeData.cTYPE_CONDITIONAL << Byte.sizeof;
  constant Item cCNST = TreeData.cTYPE_CONSTANT << Byte.sizeof;

  /*
    Item:

      type    value
      v       v
    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
   */

  Type getType(Item item) {
    return (Type) (item >> Byte.sizeof);
  }

  Byte getValue(Item item) {
    return (Byte) item;
  }
}


local typedef TreeExecFunctions EF;
local typedef TreeExecConditionals EC;

/**
  Moving to the beginning of input sequence.

  (prog2
    (input) ; select input sequence
    (prog2
      (set-1
        (quote 1) ; prev. item bond index
      (if-has-attached
        (traverse) ; move to prev. item
        (noop)))))
*/
transient ExecTestRewindData : ExecTestSequenceData {
  constant Size cSIZE = 8u;

  Item data[cSIZE] = {
    /* */ cFUNC | EF.cPROG2,
    /*     */ cFUNC | EF.cINPUT,
    /*     */ cFUNC | EF.cPROG2,
    /*         */ cFUNC | EF.cSET_1,
    /*             */ cCNST | 1u,
    /*         */ cCOND | EC.cIF_HAS_ATTACHED,
    /*             */ cFUNC | EF.cTRAVERSE,
    /*             */ cFUNC | EF.cNOOP
  };
}

/**
   Storing a sequence into memory.
   The program assumes we're initially attached to the last item for simplicity.

   (prog2
     (input)
     (if-attached
       (prog2
         (prog2 ; store current item
           (memory-prev)
           (selected-to-memory))
         (prog2
           (set-1
             (quote 1)) ; prev. item bond index
           (if-has-attached
             (traverse) ; move to prev. item
             (detach)   ; no prev. item, detach from input sequence
           )))
       (noop) ; no input
     ))

 */
transient ExecTestCopyData : ExecTestSequenceData {
  constant Size cSIZE = 14u;

  Item data[cSIZE] = {
    /* */ cFUNC | EF.cPROG2,
    /*     */ cFUNC | EF.cINPUT,
    /*     */ cCOND | EC.cIF_ATTACHED,
    /*         */ cFUNC | EF.cPROG2,
    /*             */ cFUNC | EF.cPROG2,
    /*                 */ cFUNC | EF.cMEMORY_PREV,
    /*                 */ cFUNC | EF.cSELECTED_TO_MEMORY,
    /*             */ cFUNC | EF.cPROG2,
    /*                 */ cFUNC | EF.cSET_1,
    /*                     */ cCNST | 1u,
    /*                 */ cCOND | EC.cIF_HAS_ATTACHED,
    /*                     */ cFUNC | EF.cTRAVERSE,
    /*                     */ cFUNC | EF.cDETACH,
    /*         */ cFUNC | EF.cNOOP
  };
}

/**
   Building a tree from sequence.

    1  (prog2
    2    (output)
    3    (if-attached
    4      (prog2 ;; already started building
    5        (prog2 ;; is node complete?
    6          (arity)
    7          (sub
    8            (num-attached))) ; arity - (# of children)
    9        (if-zero
    10         (prog2 ;; done, move up
    11           (set-1
    12             (quote 1)) ; parent bond index
    13           (traverse)) ;; (we trust that the sequence is correct and there is a parent node)
    14         (prog2 ;; build next child and traverse to it
    15           (prog2
    16             (prog2
    17               (prog2
    18                 (selected-to-memory)
    19                 (inc)) ; bond index to attach next child: arity - (# of children) + 1
    20               (set-2
    21                 (quote 1))) ; child to parent bond index
    22             (prog2
    23               (build-next)
    24               (traverse)))
    25           (prog2
    26             (prog2
    27               (input)
    28               (set-1
    29                 (quote 2))) ; next item bond index
    30             (if-has-attached
    31               (traverse)    ; move to next item
    32               (detach)))))) ; done
    33     (prog2   ;; no output, haven't started building yet, keep rewinding
    34       (prog2 ;; is there a prev. item?
    35         (input)
    36         (set-1
    37           (quote 1))) ; prev. item bond index
    38       (if-has-attached
    39         (traverse)
    40         (prog2   ;; beginning of sequence, build root node
    41           (prog2
    42             (selected-to-memory)
    43             (build))
    44           (prog2
    45             (set-1
    46               (quote 2)) ; next item bond index
    47             (if-has-attached
    48               (traverse)      ; move to next
    49               (detach)))))))) ; done, root is the only node
*/
transient ExecTreeBuildData : ExecTestSequenceData {
  constant Size cSIZE = 49u;

  Item data[cSIZE] = {
    /* 1 */ cFUNC | EF.cPROG2,
    /* 2     */ cFUNC | EF.cOUTPUT,
    /* 3     */ cCOND | EC.cIF_ATTACHED,
    /* 4         */ cFUNC | EF.cPROG2,
    /* 5             */ cFUNC | EF.cPROG2,
    /* 6                 */ cFUNC | EF.cARITY,
    /* 7                 */ cFUNC | EF.cSUB,
    /* 8                     */ cFUNC | EF.cNUM_ATTACHED,
    /* 9             */ cCOND | EC.cIF_ZERO,
    /* 10                */ cFUNC | EF.cPROG2,
    /* 11                    */ cFUNC | EF.cSET_1,
    /* 12                        */ cCNST | (Byte) 1u,
    /* 13                    */ cFUNC | EF.cTRAVERSE,
    /* 14                */ cFUNC | EF.cPROG2,
    /* 15                    */ cFUNC | EF.cPROG2,
    /* 16                        */ cFUNC | EF.cPROG2,
    /* 17                             */ cFUNC | EF.cPROG2,
    /* 18                                 */ cFUNC | EF.cSELECTED_TO_MEMORY,
    /* 19                                 */ cFUNC | EF.cINC,
    /* 20                             */ cFUNC | EF.cSET_2,
    /* 21                                 */ cCNST | (Byte) 1u,
    /* 22                        */ cFUNC | EF.cPROG2,
    /* 23                            */ cFUNC | EF.cBUILD_NEXT,
    /* 24                            */ cFUNC | EF.cTRAVERSE,
    /* 25                    */ cFUNC | EF.cPROG2,
    /* 26                        */ cFUNC | EF.cPROG2,
    /* 27                            */ cFUNC | EF.cINPUT,
    /* 28                            */ cFUNC | EF.cSET_1,
    /* 29                                */ cCNST | (Byte) 2u,
    /* 30                        */ cCOND | EC.cIF_HAS_ATTACHED,
    /* 31                            */ cFUNC | EF.cTRAVERSE,
    /* 32                            */ cFUNC | EF.cDETACH,
    /* 33        */ cFUNC | EF.cPROG2,
    /* 34            */ cFUNC | EF.cPROG2,
    /* 35                */ cFUNC | EF.cINPUT,
    /* 36                */ cFUNC | EF.cSET_1,
    /* 37                    */ cCNST | (Byte) 1u,
    /* 38            */ cCOND | EC.cIF_HAS_ATTACHED,
    /* 39                */ cFUNC | EF.cTRAVERSE,
    /* 40                */ cFUNC | EF.cPROG2,
    /* 41                    */ cFUNC | EF.cPROG2,
    /* 42                        */ cFUNC | EF.cSELECTED_TO_MEMORY,
    /* 43                        */ cFUNC | EF.cBUILD,
    /* 44                    */ cFUNC | EF.cPROG2,
    /* 45                        */ cFUNC | EF.cSET_1,
    /* 46                            */ cCNST | (Byte) 2u,
    /* 47                        */ cCOND | EC.cIF_HAS_ATTACHED,
    /* 48                            */ cFUNC | EF.cTRAVERSE,
    /* 49                            */ cFUNC | EF.cDETACH
  };
}
