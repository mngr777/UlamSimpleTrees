quark QBond : Fail {
  typedef EventWindow.SiteNum SiteNum;
  typedef Unsigned(6) Site;
  typedef Unsigned(3) Index;

  constant Unsigned(3) cMAX_DIST = 4u;

  Site mSite = 0u;
  Index mIndex;

  SiteNum getSite() {
    return mSite;
  }

  Bool isBonded() {
    return mSite != 0u;
  }

  Bool bond(Index index, SiteNum siteOther, Index indexOther) {
    return bond(0u, index, siteOther, indexOther);
  }

  Bool bond(SiteNum site, Index index, SiteNum siteOther, Index indexOther) {
    if (isBonded())
      return false;

    EventWindow ew;
    Atom& bondable = ew[siteOther];
    if (bondable as IBondable) {
      C2D coord = ew.getCoordRaw(site);
      C2D coordOther = ew.getCoordRaw(siteOther);
      QBond& bonded = bondable.getBond(indexOther);
      mSite = (Site) ew.getSiteNumber(coordOther - coord);
      mIndex = indexOther;
      bonded.mSite = (Site) ew.getSiteNumber(coord - coordOther);
      bonded.mIndex = index;

      return true;

    } else {
      DebugUtils du;
      du.print("QBond.bond: the other atom is not bondable");
    }
    return false;
  }

  Void breakup() {
    breakup(0u);
  }

  Bool breakup(SiteNum site) {
    if (!isBonded())
      return true;

    EventWindow ew;
    EventWindowInverse ewi;
    C2D coord = ew.getCoordRaw(site);
    C2D coordBonded = coord + ewi.getCoord(mSite);
    if (!ew.isAccessible(coordBonded))
      return false;

    Atom& bondable = ew[coordBonded];
    if (bondable as IBondable) {
      QBond& bonded = bondable.getBond(mIndex);
      bonded.mSite = 0u;
    } else {
      DebugUtils du;
      du.print("QBond.breakup: other side of the bond is not bondable");
    }
    mSite = 0u;
    return true;
  }

  Bool checkForSwap(SiteNum siteOther) {
    return checkForSwap(0u, siteOther);
  }

  Bool checkForSwap(SiteNum site, SiteNum siteOther) {
    if (!isBonded())
      return true;

    EventWindow ew;
    EventWindowInverse ewi;

    C2D coord = ew.getCoordRaw(site);
    C2D coordBonded = coord + ewi.getCoord(mSite);
    C2D coordOther = ew.getCoordRaw(siteOther);
    if (!ew.isAccessible(coordBonded))
      return false;
    return coordBonded.manhattanDistance(coordOther) <= cMAX_DIST;
  }

  Void updateForSwap(SiteNum siteOther) {
    updateForSwap(0u, siteOther);
  }

  Void updateForSwap(SiteNum site, SiteNum siteOther) {
    if (!isBonded())
      return;

    EventWindow ew;
    EventWindowInverse ewi;

    C2D coord = ew.getCoordRaw(site);
    C2D coordBonded = coord + ewi.getCoord(mSite);
    C2D coordOther = ew.getCoordRaw(siteOther);
    if (coordBonded.manhattanDistance(coordOther) > cMAX_DIST)
      fail("QBond.updateForSwap: can't swap without breaking a bond, check with QBond.checkForSwap before swapping");

    Atom& bondable = ew[coordBonded];
    if (bondable as IBondable) {
      QBond& bonded = bondable.getBond(mIndex);

      if (coordOther != coordBonded) {
        C2D diff = coordBonded - coordOther;
        mSite = (Site) ew.getSiteNumber(diff);
        bonded.mSite = (Site) ew.getSiteNumber(-diff);
      } else {
        // Swapping bond ends, update only this one
        mSite = (Site) ew.getSiteNumber(coord - coordBonded);
      }

    } else {
      DebugUtils du;
      du.print("QBond.updateForSwap: other side of the bond is not bondable");
    }
  }
}
