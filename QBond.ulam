quark QBond : Fail {
  typedef EventWindow.SiteNum SiteNum;
  typedef Unsigned(6) Site;
  typedef Unsigned(3) Index;

  constant Unsigned(3) cMAX_DIST = 4u;

  Site mSite = 0u;
  Index mIndex;

  SiteNum getSiteNumberRaw() {
    return mSite;
  }

  SiteNum getSiteNumber() {
    EventWindowInverse ewi;
    return ewi.getSiteNumber(mSite);
  }

  C2D getCoord() {
    EventWindowInverse ewi;
    return ewi.getCoord(mSite);
  }

  Bool isBonded() {
    return mSite != 0u;
  }

  Bool bond(Index index, SiteNum siteOther, Index indexOther) {
    return bond(0u, index, siteOther, indexOther);
  }

  Bool bond(SiteNum site, Index index, SiteNum siteOther, Index indexOther) {
    if (isBonded())
      return false;

    EventWindow ew;

    if (!ew.isAccessible(site) || !ew.isAccessible(siteOther))
      return false;

    C2D coord = ew.getCoordRaw(site);
    C2D coordOther = ew.getCoordRaw(siteOther);
    if (coord.manhattanDistance(coordOther) > cMAX_DIST)
      return false;

    Atom& bondable = ew[siteOther];
    if (bondable as IBondable) {
      QBond& bondOther = bondable.getBond(indexOther);
      if (bondOther.isBonded())
        return false; // the other end is already bonded

      C2D diff = coordOther - coord;
      mSite = (Site) ew.getSiteNumber(diff);
      mIndex = indexOther;
      bondOther.mSite = (Site) ew.getSiteNumber(-diff);
      bondOther.mIndex = index;

      return true;

    } else {
      DebugUtils du;
      du.print("QBond.bond: the other atom is not bondable");
    }
    return false;
  }

  Bool breakup() {
    return breakup(0u);
  }

  Bool breakup(SiteNum site) {
    if (!isBonded())
      return true;

    EventWindow ew;

    C2D coord = ew.getCoordRaw(site);
    C2D coordBonded = coord + getCoord();
    if (!ew.isAccessible(coord) || !ew.isAccessible(coordBonded))
      return false;

    Atom& bondable = ew[coordBonded];
    if (bondable as IBondable) {
      QBond& bondOther = bondable.getBond(mIndex);
      bondOther.mSite = 0u;
      mSite = 0u;
      return true;

    } else {
      DebugUtils du;
      du.print("QBond.breakup: other side of the bond is not bondable");
    }

    return false;
  }

  Bool checkForSwap(SiteNum siteOther) {
    return checkForSwap(0u, siteOther);
  }

  Bool checkForSwap(SiteNum site, SiteNum siteOther) {
    if (!isBonded())
      return true;

    EventWindow ew;
    C2D coord = ew.getCoordRaw(site);
    C2D coordBonded = coord + getCoord();
    C2D coordOther = ew.getCoordRaw(siteOther);

    if (!ew.isAccessible(coord) || !ew.isAccessible(coordBonded) || !ew.isAccessible(coordOther))
      return false;

    return coordBonded.manhattanDistance(coordOther) <= cMAX_DIST;
  }

  Void updateForSwap(SiteNum siteOther) {
    updateForSwap(0u, siteOther);
  }

  Void updateForSwap(SiteNum site, SiteNum siteOther) {
    if (!isBonded())
      return;

    EventWindow ew;
    C2D coord = ew.getCoordRaw(site);
    C2D coordBonded = coord + getCoord();
    C2D coordOther = ew.getCoordRaw(siteOther);

    if (!ew.isAccessible(coord) || !ew.isAccessible(coordBonded) || !ew.isAccessible(coordOther))
      fail("QBond.updateForSwap: some sites are inaccessible, check with QBond.checkForSwap before swapping");

    if (coordBonded.manhattanDistance(coordOther) > cMAX_DIST)
      fail("QBond.updateForSwap: can't swap without breaking a bond, check with QBond.checkForSwap before swapping");

    Atom& bondable = ew[coordBonded];
    if (bondable as IBondable) {
      QBond& bonded = bondable.getBond(mIndex);

      if (coordOther != coordBonded) {
        C2D diff = coordBonded - coordOther;
        mSite = (Site) ew.getSiteNumber(diff);
        bonded.mSite = (Site) ew.getSiteNumber(-diff);
      } else {
        // Swapping bond ends, update only this one
        mSite = (Site) ew.getSiteNumber(coord - coordBonded);
      }

    } else {
      // DebugUtils du;
      // du.print("QBond.updateForSwap: other side of the bond is not bondable");
      Fail fl;
      fl.fail("QBond.updateForSwap: other side of the bond is not bondable");
    }
  }
}
