/**
    \symbol TB
    \symmetry all
 */
element TreeBuilder : QBondableT(2u) + QDiffusableT(1000u, 2u) + QMortal {
  constant QBond.Index cSEQUENCE = 0u;
  constant QBond.Index cTREE = 1u;

  Bool mFlagForward = false;

  Void behave() {
    QBond& bondSeq = getBond(cSEQUENCE);
    if (bondSeq.isBonded() || attach()) {
      EventWindow ew;
      Sequence& item = (Sequence&) ew[bondSeq.getSiteNumber()];
      if (process(item)) {
        getBond(cTREE).breakup();
        getBond(cSEQUENCE).breakup();
        die();
        return;
      }
    }

    diffuse();
  }

  Bool attach() {
    if (getBond(cSEQUENCE).isBonded())
      return true;

    WindowServices ws;
    ws.reset(1u, QBond.cMAX_DIST);

    Sequence sequence;
    AtomUtils au;
    ws.scan(au.getType(sequence));
    if (ws.getHits() == 0u)
      return false;

    return getBond(cSEQUENCE)
      .bond(cSEQUENCE, ws.getPick(), Sequence.cCOMMON);
  }

  Bool process(Sequence& item) {
    if (!getBond(cTREE).isBonded() && !item.isFirst()) {
      // Find first item to start building
      backward();

    } else if (mFlagForward) {
      // Move to next item
      forward();

    } else if (build(item)) {
      if (!item.isLast()) {
        // More work to do
        mFlagForward = true;
      } else {
        // Done
        return true;
      }
    }
    return false;
  }

  Void backward() {
    BondUtils bu;
    bu.traverse(cSEQUENCE, Sequence.cPREV, Sequence.cCOMMON);
  }

  Void forward() {
    BondUtils bu;
    if (bu.traverse(cSEQUENCE, Sequence.cNEXT, Sequence.cCOMMON))
      mFlagForward = false;
  }

  Bool build(Sequence& item) {
    return true;
  }
}
